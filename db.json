[
    {
        "title": "ООП(Stepik) --> Концепция ООП простыми словами",
        "text": "У многих начинающих программистов концепция ООП вызывает недоумение и вопрос: зачем она нужна? Я же уже умею писать программы: оперировать данными, создавать циклы, прописывать условия, вызывать функции и тем самым писать программы практически любой сложности? Разве этого мало? Этого было достаточно до 1960-x гг. когда, в общем то и зародилась эта концепция ООП. Даже можно сказать, что вплоть до начала 1990-х программисты могли свободно обходиться без ООП, пока оно не стало доминирующим направлением и внедрено в самый популярный (на тот момент) язык программирования С++. Так что же это такое и почему сейчас знать ООП должен каждый, уважающий себя, начинающий программист?",
        "URL": "https://www.notion.so/75d92d1e7148450a85748a50a170a489/"
    },
    {
        "title": "ООП(Stepik) --> Распространение исключений (propagation exceptions)",
        "text": "То есть, мы можем обрабатывать исключения на разных уровнях стека вызова, что очень удобно. Этот механизм обработки исключений позволяет программистам писать независимый, модульный, красивый код. В критических функциях достаточно генерировать исключения, а их обработку выполнять на другом, более глобальном уровне. Например, создается класс для печати данных на принтере. Тогда все ошибки, связанные с принтером (нет бумаги, нет подключения, не тот режим печати и т.п.) можно обрабатывать единым образом на верхнем, глобальном уровне. А нижние уровни только сигнализируют о проблемах и не более того. В результате, получается разделение ролей: функции нижних уровней сосредоточены исключительно на обработке данных, а функции верхних – на формировании сервисной информации для пользователя.",
        "URL": "https://www.notion.so/165fadc6ff544ce1a68e494e6dc013c0/"
    },
    {
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "Хорошо спроектированное приложение должно решать только одну задачу. В противном случае его будет сложно переносить.",
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/"
    },
    {
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "Команда startapp создаёт базовую структуру файлов, которая, по мнению разработчиков Django, пригодится для любого приложения. При этом никакой магии не происходит: все эти файлы можно создать и вручную, но автоматически — удобнее и быстрее.",
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/"
    },
    {
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "В некоторых книгах и статьях предлагается регистрировать приложение так: добавлять в INSTALLED_APPS не имя конфигурирующего класса catalog.apps.CatalogConfig, а просто имя приложения — 'catalog'. Но разработчики Django рекомендуют регистрировать приложения через конфигурирующий класс. В нашем курсе мы придерживаемся их рекомендаций.",
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/"
    },
    {
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Консистентность — это согласованность данных друг с другом, их целостность и внутренняя непротиворечивость. Например, данные о каком-то объекте, полученные с одного эндпоинта, не должны отличаться от данных о том же объекте, но полученных с другого эндпоинта.",
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/"
    },
    {
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Понятие консистентности включает в себя и идею согласованности: добавление в API новой функциональности не должно сломать API. Например, при проектировании блога было решено возвращать через API не словарь, а упорядоченный список значений. Это допустимое решение, JSON поддерживает и такую структуру данных.",
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/"
    },
    {
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "При проектировании API именно разработчик определяет, какие данные и в каком формате будут возвращаться в ответ на тот или иной запрос. Сейчас API возвращает данные в виде упорядоченного списка: [[1, \"Это мой первый комментарий.\", 1618565516, 10]]. Так иногда делают для повышения производительности, но в нашей ситуации этот вариант оказался непрактичен: он усложняет расширяемость. Здесь лучше отдавать данные в более распространённом для JSON формате, аналогичном словарю, со структурой {\"ключ\": \"значение\"}. При такой структуре добавление новых элементов не повлечёт за собой проблем с парсингом данных. Клиенты будут получать необходимую информацию из ответа по прежним ключам, а новые ключи могут использовать, а могут игнорировать. И ничего не сломается.",
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/"
    }
]