[
    {
        "card_number": 1,
        "title": "ООП(Stepik) --> Концепция ООП простыми словами",
        "text": "У многих начинающих программистов концепция ООП вызывает недоумение и вопрос: зачем она нужна? Я же уже умею писать программы: оперировать данными, создавать циклы, прописывать условия, вызывать функции и тем самым писать программы практически любой сложности? Разве этого мало? Этого было достаточно до 1960-x гг. когда, в общем то и зародилась эта концепция ООП. Даже можно сказать, что вплоть до начала 1990-х программисты могли свободно обходиться без ООП, пока оно не стало доминирующим направлением и внедрено в самый популярный (на тот момент) язык программирования С++. Так что же это такое и почему сейчас знать ООП должен каждый, уважающий себя, начинающий программист?",
        "code": null,
        "URL": "https://www.notion.so/75d92d1e7148450a85748a50a170a489/"
    },
    {
        "card_number": 2,
        "title": "ООП(Stepik) --> Распространение исключений (propagation exceptions)",
        "text": "Мы можем обрабатывать исключения на разных уровнях стека вызова, что очень удобно. Этот механизм обработки исключений позволяет программистам писать независимый, модульный, красивый код. В критических функциях достаточно генерировать исключения, а их обработку выполнять на другом, более глобальном уровне. Например, создается класс для печати данных на принтере. Тогда все ошибки, связанные с принтером (нет бумаги, нет подключения, не тот режим печати и т.п.) можно обрабатывать единым образом на верхнем, глобальном уровне. А нижние уровни только сигнализируют о проблемах и не более того. В результате, получается разделение ролей: функции нижних уровней сосредоточены исключительно на обработке данных, а функции верхних – на формировании сервисной информации для пользователя.",
        "code": null,
        "URL": "https://www.notion.so/165fadc6ff544ce1a68e494e6dc013c0/"
    },
    {
        "card_number": 3,
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "Хорошо спроектированное приложение должно решать только одну задачу. В противном случае его будет сложно переносить.",
        "code": null,
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/"
    },
    {
        "card_number": 4,
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "Команда startapp создаёт базовую структуру файлов, которая, по мнению разработчиков Django, пригодится для любого приложения. При этом никакой магии не происходит: все эти файлы можно создать и вручную, но автоматически — удобнее и быстрее.",
        "code": null,
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/"
    },
    {
        "card_number": 5,
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "В некоторых книгах и статьях предлагается регистрировать приложение так: добавлять в INSTALLED_APPS не имя конфигурирующего класса catalog.apps.CatalogConfig, а просто имя приложения — 'catalog'. Но разработчики Django рекомендуют регистрировать приложения через конфигурирующий класс. В нашем курсе мы придерживаемся их рекомендаций.",
        "code": null,
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/"
    },
    {
        "card_number": 6,
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Консистентность — это согласованность данных друг с другом, их целостность и внутренняя непротиворечивость. Например, данные о каком-то объекте, полученные с одного эндпоинта, не должны отличаться от данных о том же объекте, но полученных с другого эндпоинта. Другой случай соблюдения принципа консистентности: одинаковые типы данных должны быть описаны одинаково, где бы они ни использовались:",
        "code": null,
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/"
    },
    {
        "card_number": 7,
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Понятие консистентности включает в себя и идею согласованности: добавление в API новой функциональности не должно сломать API. Например, при проектировании блога было решено возвращать через API не словарь, а упорядоченный список значений. Это допустимое решение, JSON поддерживает и такую структуру данных:",
        "code": "# GET запрос поста с id=10\nGET /api/v1/posts/10/\n\n# Ответ API\n[[10, \"Это текст из моего поста.\", 1618567801, 1]]",
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/"
    },
    {
        "card_number": 8,
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Расширяемость. При проектировании API именно разработчик определяет, какие данные и в каком формате будут возвращаться в ответ на тот или иной запрос. Сейчас API возвращает данные в виде упорядоченного списка: [[1, \"Это мой первый комментарий.\", 1618565516, 10]]. Так иногда делают для повышения производительности, но в нашей ситуации этот вариант оказался непрактичен: он усложняет расширяемость. Здесь лучше отдавать данные в более распространённом для JSON формате, аналогичном словарю, со структурой {\"ключ\": \"значение\"}. При такой структуре добавление новых элементов не повлечёт за собой проблем с парсингом данных. Клиенты будут получать необходимую информацию из ответа по прежним ключам, а новые ключи могут использовать, а могут игнорировать. И ничего не сломается.",
        "code": null,
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/"
    },
    {
        "card_number": 9,
        "title": "Django Rest Framework --> View-функции API",
        "text": "Для «настройки» view-функции на работу с API в Django REST framework есть декоратор @api_view. В качестве аргумента декоратору передают список типов HTTP-запросов, которые должна обрабатывать эта функция:",
        "code": "@api_view([<разрешённые типы HTTP-запросов>])\ndef hello(request):\n...",
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/"
    },
    {
        "card_number": 10,
        "title": "Django Rest Framework --> View-функции API",
        "text": "Ещё одно отличие view-функции API в Django REST framework состоит в том, что они возвращают специальный объект класса Response; в этот объект в качестве аргумента передаётся Python-словарь, данные из которого и должны быть отправлены в ответ на запрос в JSON формате.",
        "code": null,
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/"
    },
    {
        "card_number": 11,
        "title": "Django Rest Framework --> View-функции API",
        "text": "При разработке Rest API хорошей практикой считается всегда возвращать соответствующий ситуации статус-код ответа. Если в коде не указать статус ответа — он всё равно будет отправлен автоматически; однако в таком случае может вернуться код, не отражающий реальное состояние дел. Список возможных кодов и их описание можно посмотреть здесь, в документации Django REST framework.",
        "code": null,
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/"
    },
    {
        "card_number": 12,
        "title": "Django Rest Framework --> View-функции API",
        "text": "Чтобы сериализатор был готов принять список объектов, в конструктор сериализатора нужно передать именованный параметр many=True. Если этот параметр не указан, сериализатор не станет обрабатывать список объектов и вернёт ошибку: \"Invalid data. Expected a dictionary, but got list.\"",
        "code": null,
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/"
    },
    {
        "card_number": 13,
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "Вьюсет (англ. viewset, «набор представлений») — это высокоуровневый view-класс, реализующий все операции CRUD; он может вернуть объект или список объектов, создать, изменить или удалить объекты. Во вьюсеты встроена обработка разных типов запросов, работа с сериализаторами и моделями, фильтрация и пагинация результатов, возврат ошибок. Не нужно ничего придумывать: всё работает «из коробки». В библиотеке rest_framework есть несколько разных вьюсетов, они хранятся в пакете viewsets.",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/"
    },
    {
        "card_number": 14,
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "Класс ModelViewSet может выполнять любые операции CRUD с моделью. От разработчика не требуется описывать методы для чтения и записи данных для модели: эти операции уже реализованы.",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/"
    },
    {
        "card_number": 15,
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "В пакете rest_framework.viewsets есть похожий на ModelViewSet, но ограниченный в правах класс ReadOnlyModelViewSet. Он может только получать данные модели, а записывать и изменять — не может. Этот класс полезен в ситуациях, когда требуется только выдавать данные по запросу, без возможности их изменить. В остальном ReadOnlyModelViewSet работает точно так же, как и ModelViewSet.",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/"
    },
    {
        "card_number": 16,
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "При работе с view-классами и дженериками каждый эндпоинт отдельно описывается в urls.py. Но для вьюсетов есть более удобный и экономичный инструмент — роутеры (англ. routers).",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/"
    }
]