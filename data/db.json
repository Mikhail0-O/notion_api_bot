[
    {
        "created_time": 1710640920,
        "block_id": "31b104f6-d36a-4dba-b48d-00e28d63765b",
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "Хорошо спроектированное приложение должно решать только одну задачу. В противном случае его будет сложно переносить.",
        "code": null,
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/",
        "card_number": 1
    },
    {
        "created_time": 1710640920,
        "block_id": "5d030963-2762-4853-8236-bf520e7d8dff",
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "Команда startapp создаёт базовую структуру файлов, которая, по мнению разработчиков Django, пригодится для любого приложения. При этом никакой магии не происходит: все эти файлы можно создать и вручную, но автоматически — удобнее и быстрее.",
        "code": null,
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/",
        "card_number": 2
    },
    {
        "created_time": 1710640920,
        "block_id": "8eef2d9e-713a-4f9f-9e0e-96ce617356d0",
        "title": "Django --> Создание Django-проекта. Приложения",
        "text": "В некоторых книгах и статьях предлагается регистрировать приложение так: добавлять в INSTALLED_APPS не имя конфигурирующего класса catalog.apps.CatalogConfig, а просто имя приложения — 'catalog'. Но разработчики Django рекомендуют регистрировать приложения через конфигурирующий класс. В нашем курсе мы придерживаемся их рекомендаций.",
        "code": null,
        "URL": "https://www.notion.so/f279f43033c949dcb23e82461d44e23f/",
        "card_number": 3
    },
    {
        "created_time": 1717843560,
        "block_id": "0749f834-789b-4c0c-bc3c-ccc41422c2c8",
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Консистентность — это согласованность данных друг с другом, их целостность и внутренняя непротиворечивость. Например, данные о каком-то объекте, полученные с одного эндпоинта, не должны отличаться от данных о том же объекте, но полученных с другого эндпоинта. Другой случай соблюдения принципа консистентности: одинаковые типы данных должны быть описаны одинаково, где бы они ни использовались:",
        "code": null,
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/",
        "card_number": 4
    },
    {
        "created_time": 1717843560,
        "block_id": "59903a1e-e4ef-448f-a427-c72b85a89e60",
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Понятие консистентности включает в себя и идею согласованности: добавление в API новой функциональности не должно сломать API. Например, при проектировании блога было решено возвращать через API не словарь, а упорядоченный список значений. Это допустимое решение, JSON поддерживает и такую структуру данных:",
        "code": "# GET запрос поста с id=10\nGET /api/v1/posts/10/\n\n# Ответ API\n[[10, \"Это текст из моего поста.\", 1618567801, 1]]",
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/",
        "card_number": 5
    },
    {
        "created_time": 1717843560,
        "block_id": "12db84d2-21b9-45da-8cd9-3e8741b7e593",
        "title": "Django Rest Framework --> REST API: Проектирование",
        "text": "Расширяемость. При проектировании API именно разработчик определяет, какие данные и в каком формате будут возвращаться в ответ на тот или иной запрос. Сейчас API возвращает данные в виде упорядоченного списка: [[1, \"Это мой первый комментарий.\", 1618565516, 10]]. Так иногда делают для повышения производительности, но в нашей ситуации этот вариант оказался непрактичен: он усложняет расширяемость. Здесь лучше отдавать данные в более распространённом для JSON формате, аналогичном словарю, со структурой {\"ключ\": \"значение\"}. При такой структуре добавление новых элементов не повлечёт за собой проблем с парсингом данных. Клиенты будут получать необходимую информацию из ответа по прежним ключам, а новые ключи могут использовать, а могут игнорировать. И ничего не сломается.",
        "code": null,
        "URL": "https://www.notion.so/61d14bf1877a4db7b929eaa98a88db1f/",
        "card_number": 6
    },
    {
        "created_time": 1717905240,
        "block_id": "daf35d52-e1c9-4ac6-bd7e-742d5fa8191f",
        "title": "Django Rest Framework --> View-функции API",
        "text": "Для «настройки» view-функции на работу с API в Django REST framework есть декоратор @api_view. В качестве аргумента декоратору передают список типов HTTP-запросов, которые должна обрабатывать эта функция:",
        "code": "@api_view([<разрешённые типы HTTP-запросов>])\ndef hello(request):\n...",
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/",
        "card_number": 7
    },
    {
        "created_time": 1717905240,
        "block_id": "3925cede-c520-4bfd-8c7d-23ca083dcffa",
        "title": "Django Rest Framework --> View-функции API",
        "text": "Ещё одно отличие view-функции API в Django REST framework состоит в том, что они возвращают специальный объект класса Response; в этот объект в качестве аргумента передаётся Python-словарь, данные из которого и должны быть отправлены в ответ на запрос в JSON формате.",
        "code": null,
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/",
        "card_number": 8
    },
    {
        "created_time": 1717905240,
        "block_id": "b392d59e-5e21-4195-8d43-7c5cb32489c6",
        "title": "Django Rest Framework --> View-функции API",
        "text": "При разработке Rest API хорошей практикой считается всегда возвращать соответствующий ситуации статус-код ответа. Если в коде не указать статус ответа — он всё равно будет отправлен автоматически; однако в таком случае может вернуться код, не отражающий реальное состояние дел. Список возможных кодов и их описание можно посмотреть здесь, в документации Django REST framework.",
        "code": null,
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/",
        "card_number": 9
    },
    {
        "created_time": 1717905240,
        "block_id": "a52ffc46-7bf2-4e04-9a6e-ab891bcc0c52",
        "title": "Django Rest Framework --> View-функции API",
        "text": "Чтобы сериализатор был готов принять список объектов, в конструктор сериализатора нужно передать именованный параметр many=True. Если этот параметр не указан, сериализатор не станет обрабатывать список объектов и вернёт ошибку: \"Invalid data. Expected a dictionary, but got list.\"",
        "code": null,
        "URL": "https://www.notion.so/77a1cf87601d4c81aba264dace12a1fc/",
        "card_number": 10
    },
    {
        "created_time": 1719801000,
        "block_id": "e3378503-8596-4f4a-8f00-860dbdab16bd",
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "Вьюсет (англ. viewset, «набор представлений») — это высокоуровневый view-класс, реализующий все операции CRUD; он может вернуть объект или список объектов, создать, изменить или удалить объекты. Во вьюсеты встроена обработка разных типов запросов, работа с сериализаторами и моделями, фильтрация и пагинация результатов, возврат ошибок. Не нужно ничего придумывать: всё работает «из коробки». В библиотеке rest_framework есть несколько разных вьюсетов, они хранятся в пакете viewsets.",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/",
        "card_number": 11
    },
    {
        "created_time": 1719801120,
        "block_id": "5c1b4641-8d1b-4f02-acf2-db9a707ee716",
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "Класс ModelViewSet может выполнять любые операции CRUD с моделью. От разработчика не требуется описывать методы для чтения и записи данных для модели: эти операции уже реализованы.",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/",
        "card_number": 12
    },
    {
        "created_time": 1719801120,
        "block_id": "0a3d58f3-f1c0-4ec6-b6db-e56e1a3fbcd8",
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "В пакете rest_framework.viewsets есть похожий на ModelViewSet, но ограниченный в правах класс ReadOnlyModelViewSet. Он может только получать данные модели, а записывать и изменять — не может. Этот класс полезен в ситуациях, когда требуется только выдавать данные по запросу, без возможности их изменить. В остальном ReadOnlyModelViewSet работает точно так же, как и ModelViewSet.",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/",
        "card_number": 13
    },
    {
        "created_time": 1719801180,
        "block_id": "ebe89f68-32ac-4af0-bf6f-b5bec5cb1959",
        "title": "Django Rest Framework --> Вьюсеты и роутеры",
        "text": "При работе с view-классами и дженериками каждый эндпоинт отдельно описывается в urls.py. Но для вьюсетов есть более удобный и экономичный инструмент — роутеры (англ. routers).",
        "code": null,
        "URL": "https://www.notion.so/77853dcc9bfd426e8dc0cf5cd5ad59a3/",
        "card_number": 14
    },
    {
        "created_time": 1720933080,
        "block_id": "9c8a9dbf-42cc-44d4-a4ad-b0f7d8ea53cb",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Любая достаточно длительная операция может блокировать приложение, но особенно часто это бывает, когда приложение ждет завершения ввода-вывода. Ввод-вывод выполняют такие устройства, как клавиатура, жесткий диск и,  конечно же, сетевая карта. Такие операции ждут ввода от пользователя или получения содержимого от веб-API. В синхронном приложении мы будем ждать завершения операции и до тех пор ничего не сможем делать. Это ведет к проблемам с производительностью и отзывчивостью, поскольку в каждый момент времени может выполняться только одна длительная операция, а она не дает приложению больше ничего делать. Один из способов решения этой проблемы  – ввести в  программу конкурентность. Говоря по-простому, конкурентность позволяет одновременно выполнять более одной задачи. Примерами конкурентного ввода-вывода могут служить одновременная отправка нескольких веб-запросов или создание одновременных подключений к веб-серверу. В Python есть несколько способов организовать такую конкурентность. Одним из последних добавлений в экосистему Python является библиотека асинхронного ввода-вывода asyncio. Она позволяет исполнять код в рамках модели асинхронного программирования, т. е. производить сразу несколько операций ввода-вывода, не жертвуя отзывчивостью приложения.",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 15
    },
    {
        "created_time": 1720933080,
        "block_id": "ddeba08d-562d-4ff4-9621-083c39895edf",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Так что же означают слова «асинхронное программирование»? Что длительную задачу можно выполнять в фоновом режиме отдельно от главного приложения. И система не блокируется в ожидании завершения этой задачи, а может заниматься другими вещами, не зависящими от ее исхода. Затем, по завершении задачи, мы получим уведомление о том, что она все сделала, и сможем обработать результат.",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 16
    },
    {
        "created_time": 1720933080,
        "block_id": "6a236a8d-5ef4-4962-8dda-41eda138c16c",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Сопрограмма – это метод, который можно приостановить, если имеется потенциально длительная задача, а затем возобновить, когда она завершится. В Python 3.5 в самом языке была реализована полноценная поддержка сопрограмм и  асинхронного программирования, для чего были добавлены ключевые слова async и  await. Этот синтаксис, общий с  другими языками программирования, например C и  JavaScript, позволяет писать асинхронный код так, что он выглядит как синхронный. Такой асинхронный код проще читать и понимать, поскольку он похож на последовательный код, с которым большинство программистов хорошо знакомо. ",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 17
    },
    {
        "created_time": 1720933080,
        "block_id": "35da8d04-e36f-4e36-95aa-0416bd4d6257",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Библиотека asyncio исполняет сопрограммы асинхронно, пользуясь моделью конкурентности, получившей название однопоточный цикл событий. Название asyncio может навести на мысль, будто библиотека годится только для операций ввода-вывода. Но на самом деле она способна выполнять и  операции других типов благодаря взаимодействию с  механизмами многопроцессности и  многопоточности. Поэтому синтаксис async и await можно использовать в сочетании с процессами и потоками, что делает соответствующий код понятнее. Следовательно, библиотека пригодна не только для организации конкурентного ввода-вывода, но и для выполнения счетных задач, активно использующих процессор.",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 18
    },
    {
        "created_time": 1720933080,
        "block_id": "5d32466e-a2c6-47da-8efc-09c3b6fa00ea",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Операция, ограниченная быстродействием процессора (счетная операция), завершилась бы быстрее, будь процессор более мощным, например с  частотой 3, а  не 2 ГГц. Операция, ограниченная производительностью ввода-вывода, работала бы быстрее, если бы устройство могло обработать больше данных за меньшее время. Для этого можно было бы увеличить пропускную способность сети, заплатив больше денег интернет-провайдеру или поставив более шуструю сетевую карту.",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 19
    },
    {
        "created_time": 1720933080,
        "block_id": "3a828ec3-c39e-4aba-9bee-47bf1e5751a5",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Операции, ограниченные производительностью ввода-вывода и быстродействием процессора, обычно сосуществуют бок о бок. Сначала мы выполняем ограниченный производительностью ввода-вывода запрос, чтобы скачать содержимое страницы. Получив ответ, мы выполняем ограниченный быстродействием процессора цикл форматирования заголовков ответа, в котором они преобразуются в строку и разделяются символами новой строки. Затем мы открываем файл и записываем в него строку – обеоперации ограничены производительностью ввода-вывода. ",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 20
    },
    {
        "created_time": 1720933080,
        "block_id": "e8109e90-fc84-497a-ae86-6d6ef1b38e20",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Асинхронный ввод-вывод позволяет приостановить выполнение\nметода, встретив операцию ввода-вывода; ожидая завершения этой\nоперации, работающей в фоновом режиме, мы можем выполнять какой-нибудь другой код. Это позволяет выполнять одновременно много операций ввода-вывода и тем самым ускорить работу приложения.",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 21
    },
    {
        "created_time": 1720933080,
        "block_id": "8c84a636-42ff-45c9-95b0-4051e3268bc0",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Конкурентность и параллелизм.\n\nПусть работают два приложения. В конкурентной системе мы можем переключаться между ними, дав немного поработать сначала одному, а потом другому. Если делать это достаточно быстро, создается впечатление, что два дела делаются одновременно. В  параллельной системе два приложения работают действительно одновременно, т.е. оба активны в одно и то же время. Понятия конкурентности и параллелизма похожи, и различить их бывает затруднительно, но важно хорошо понимать, чем они отличаются. \n\nКонкурентность возможна, когда несколько задач может работать независимо друг от друга. Конкурентность можно организовать, имея процессор всего с одним ядром, применив вытесняющую многозадачность (определяется в следующем разделе) для переключения между задачами. С другой стороны, параллелизм означает, что мы должны выполнять две задачи или более строго одновременно. На машине с одним ядром это невозможно, необходимо иметь процессор с несколькими ядрами. \nПараллелизм подразумевает конкурентность, но обратное верно не всегда. Многопоточное приложение, работающее на многоядерной машине, является и конкурентным, и параллельным. В этом случае имеется несколько задач, работающих одновременно, и два ядра, независимо исполняющих код этих задач. Но многозадачность допускает также наличие нескольких задач, работающих конкурентно, но так, что в каждый момент времени выполняется только одна.",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 22
    },
    {
        "created_time": 1720933080,
        "block_id": "14e9049a-215b-4783-a98c-fb89ec49d341",
        "title": "ZAsyncio и конкурентное программирование на Python|Книга",
        "text": "Вытесняющая и кооперативная многозадачность. \nПри вытесняющей модели мы позволяем операционной системе решить, как переключаться между выполняемыми задачами с помощью процедуры квантования времени. Когда операционная система переключает задачи, мы говорим, что имеет место вытеснение. Как устроен этот механизм, зависит от операционной системы. Обычно для этого используется либо несколько потоков, либо несколько процессов.\n \nПри кооперативной модели мы не полагаемся для переключения между задачами на операционную систему, а явно определяем в коде приложения\nточки, где можно уступить управление другой задаче. Исполняемые\nзадачи кооперируются, т. е. говорят приложению: «Я сейчас на время\nприостановлюсь, а ты можешь пока выполнять другие задачи».\n\nВ asyncio для организации конкурентности используется кооперативная многозадачность. Когда приложение доходит до точки, в которой может подождать результата, мы явно помечаем это в коде. Поэтому другой код может работать, пока мы ждем получения результата, вычисляемого в фоновом режиме. Как только вычисление результата завершится, мы «просыпаемся» и возобновляем задачу. Это является формой конкурентности, потому что несколько задач может работать одновременно, но – и это очень важно – не параллельно, так как их выполнение чередуется. У кооперативной многозадачности есть ряд преимуществ перед вытесняющей. \n\nВо-первых, кооперативная многозадачность потребляет меньше ресурсов. Когда операционной системе нужно переключиться между потоками или процессами, мы говорим, что имеет место контекстное переключение. Это трудоемкая операция, потому что операционная система должна сохранить всю информацию о работающем процессе или потоке, чтобы потом его можно было возобновить. \n\nВторое преимущество  – гранулярность. Операционная система\nприостанавливает поток или процесс в соответствии со своим алгоритмом планирования, но выбранный для этого момент не всегда оптимален. В случае кооперативной многозадачности мы явно помечаем точки, в которых приостановить задачу наиболее выгодно. Это дает выигрыш в эффективности, потому что мы переключаем задачи именно в тот момент, когда это нужно.",
        "code": null,
        "URL": "https://www.notion.so/18daa5b850834903a24fb12e69d18793/",
        "card_number": 23
    },
    {
        "created_time": 1718976300,
        "block_id": "4272e785-1c25-4d95-9cef-e023bcc94ebe",
        "title": "ООП(Stepik) --> Распространение исключений (propagation exceptions)",
        "text": "Мы можем обрабатывать исключения на разных уровнях стека вызова, что очень удобно. Этот механизм обработки исключений позволяет программистам писать независимый, модульный, красивый код. В критических функциях достаточно генерировать исключения, а их обработку выполнять на другом, более глобальном уровне. Например, создается класс для печати данных на принтере. Тогда все ошибки, связанные с принтером (нет бумаги, нет подключения, не тот режим печати и т.п.) можно обрабатывать единым образом на верхнем, глобальном уровне. А нижние уровни только сигнализируют о проблемах и не более того. В результате, получается разделение ролей: функции нижних уровней сосредоточены исключительно на обработке данных, а функции верхних – на формировании сервисной информации для пользователя.",
        "code": null,
        "URL": "https://www.notion.so/165fadc6ff544ce1a68e494e6dc013c0/",
        "card_number": 24
    }
]